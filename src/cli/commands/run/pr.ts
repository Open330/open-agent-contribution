import type { Task } from "../../../core/index.js";
import { execa } from "execa";
import type { ExecutionOutcome, SandboxInfo, TaskRunResult } from "./types.js";
import { PR_CREATION_TIMEOUT_MS } from "./types.js";

const GITHUB_API_BASE_URL = "https://api.github.com";
const OAC_PR_TITLE_PREFIX = "[OAC]";

export async function createPullRequest(input: {
  task: Task;
  execution: ExecutionOutcome;
  sandbox?: SandboxInfo;
  repoFullName: string;
  baseBranch: string;
  ghToken?: string;
}): Promise<TaskRunResult["pr"] | undefined> {
  if (!input.sandbox) {
    return undefined;
  }

  const { branchName, sandboxPath } = input.sandbox;

  try {
    // Build env with explicit GitHub token to avoid interactive device flow
    const ghEnv: Record<string, string> = { ...process.env } as Record<string, string>;
    if (input.ghToken) {
      ghEnv.GH_TOKEN = input.ghToken;
      ghEnv.GITHUB_TOKEN = input.ghToken;
    }

    // Pre-PR guard: skip if another OAC instance already created a PR for this issue
    if (input.task.linkedIssue && input.ghToken) {
      const duplicate = await findExistingOacPR(
        input.repoFullName,
        input.task.linkedIssue.number,
        input.ghToken,
      );
      if (duplicate) {
        console.warn(
          `[oac] Skipping PR: existing OAC PR #${duplicate} already targets issue #${input.task.linkedIssue.number}`,
        );
        return undefined;
      }
    }

    // Push the branch from the sandbox worktree
    await execa("git", ["push", "--set-upstream", "origin", branchName], {
      cwd: sandboxPath,
      env: ghEnv,
      timeout: PR_CREATION_TIMEOUT_MS,
    });

    // Create PR using gh CLI
    const prTitle = `[OAC] ${input.task.title}`;
    const prBodyLines = [
      "## Summary",
      "",
      input.task.description || `Automated contribution for task "${input.task.title}".`,
      "",
    ];

    // Auto-resolve: link PR to GitHub issue so it closes on merge
    if (input.task.linkedIssue) {
      prBodyLines.push(`Closes #${input.task.linkedIssue.number}`, "");
    }

    prBodyLines.push(
      "## Context",
      "",
      `- **Task source:** ${input.task.source}`,
      `- **Complexity:** ${input.task.complexity}`,
      `- **Tokens used:** ${input.execution.totalTokensUsed}`,
      `- **Files changed:** ${input.execution.filesChanged.length}`,
    );

    if (input.task.linkedIssue) {
      prBodyLines.push(`- **Resolves:** #${input.task.linkedIssue.number}`);
    }

    prBodyLines.push(
      "",
      "---",
      "*This PR was automatically generated by [OAC](https://github.com/Open330/open-agent-contribution).*",
    );

    const prBody = prBodyLines.join("\n");

    const ghResult = await execa(
      "gh",
      [
        "pr",
        "create",
        "--repo",
        input.repoFullName,
        "--title",
        prTitle,
        "--body",
        prBody,
        "--head",
        branchName,
        "--base",
        input.baseBranch,
      ],
      { cwd: sandboxPath, env: ghEnv, timeout: PR_CREATION_TIMEOUT_MS },
    );

    // Parse PR URL from gh output
    const prUrl = ghResult.stdout.trim();
    const prNumberMatch = prUrl.match(/\/pull\/(\d+)/);
    const prNumber = prNumberMatch ? Number.parseInt(prNumberMatch[1], 10) : 0;

    return {
      number: prNumber,
      url: prUrl,
      status: "open",
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    console.warn(`[oac] PR creation failed: ${message}`);
    return undefined;
  }
}

/**
 * Pre-PR guard: checks for an existing open OAC pull request targeting
 * the given issue number. Returns the PR number if found.
 */
async function findExistingOacPR(
  repoFullName: string,
  issueNumber: number,
  token: string,
): Promise<number | undefined> {
  const url =
    `${GITHUB_API_BASE_URL}/repos/${repoFullName}` +
    `/pulls?state=open&per_page=100&sort=updated&direction=desc`;

  try {
    const response = await fetch(url, {
      method: "GET",
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/vnd.github.v3+json",
      },
      signal: AbortSignal.timeout(15_000),
    });

    if (!response.ok) {
      return undefined;
    }

    const pulls: unknown = await response.json();
    if (!Array.isArray(pulls)) {
      return undefined;
    }

    const issueRefPattern = /(?:Fixes|Closes|Resolves)\s+#(\d+)/gi;
    for (const pr of pulls) {
      if (!pr || typeof pr !== "object") continue;

      const record = pr as Record<string, unknown>;
      const title = typeof record.title === "string" ? record.title : "";
      if (!title.startsWith(OAC_PR_TITLE_PREFIX)) continue;

      const prNumber =
        typeof record.number === "number" ? record.number : undefined;
      const body = typeof record.body === "string" ? record.body : "";

      for (const match of body.matchAll(issueRefPattern)) {
        const num = Number.parseInt(match[1], 10);
        if (num === issueNumber) {
          return prNumber;
        }
      }
    }

    return undefined;
  } catch {
    // Guard failure should not block PR creation.
    return undefined;
  }
}

