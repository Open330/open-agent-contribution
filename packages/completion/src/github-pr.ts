import type { Octokit } from "@octokit/rest";
import { type ResolvedRepo, completionError } from "@open330/oac-core";
import { type SimpleGit, simpleGit } from "simple-git";

import type { CreatedPR, PRCreationParams } from "./types.js";

interface PRDiffStats {
  filesChanged: number;
  linesAdded: number;
  linesRemoved: number;
}

export async function createPR(params: PRCreationParams, octokit: Octokit): Promise<CreatedPR> {
  const { repo, task, result, branchName, baseBranch } = params;
  const pushedSha = await pushBranch(repo, branchName);
  const body = await buildPrBody(params);

  try {
    const created = await octokit.pulls.create({
      owner: repo.owner,
      repo: repo.name,
      title: `[OAC] ${task.title}`,
      body,
      head: branchName,
      base: baseBranch,
      draft: false,
    });

    await addLabels(octokit, repo, created.data.number, ["oac-contribution", task.source]);

    return {
      number: created.data.number,
      url: created.data.html_url,
      sha: created.data.head.sha || pushedSha,
    };
  } catch (error) {
    throw completionError(
      "PR_CREATION_FAILED",
      `Failed to create PR for "${repo.fullName}" on branch "${branchName}".`,
      {
        cause: error,
        context: {
          repo: repo.fullName,
          branchName,
          baseBranch,
          taskId: task.id,
        },
      },
    );
  }
}

export async function pushBranch(repo: ResolvedRepo, branchName: string): Promise<string> {
  const git = simpleGit(resolveGitPath(repo));
  const headSha = (await git.revparse(["HEAD"])).trim();

  try {
    const remoteSha = await readRemoteBranchSha(git, branchName);
    if (remoteSha !== headSha) {
      await git.push("origin", branchName);
    }
  } catch (error) {
    try {
      await git.raw(["push", "--set-upstream", "origin", branchName]);
    } catch (retryError) {
      throw completionError(
        "PR_PUSH_REJECTED",
        `Failed to push branch "${branchName}" for "${repo.fullName}".`,
        {
          cause: retryError,
          context: {
            repo: repo.fullName,
            branchName,
            headSha,
            initialError: error instanceof Error ? error.message : "unknown push error",
          },
        },
      );
    }
  }

  return headSha;
}

async function buildPrBody(params: PRCreationParams): Promise<string> {
  const { repo, task, result, baseBranch, branchName } = params;
  const diffStats = await resolveDiffStats(repo, baseBranch, branchName);
  const linkedIssue = task.linkedIssue ? `\nFixes #${task.linkedIssue.number}\n` : "\n";
  const agentLabel = resolveAgentLabel(task.metadata);
  const durationText = formatDurationSeconds(result.duration);
  const summaryText =
    task.description.trim().length > 0
      ? task.description.trim()
      : `Automated contribution for task "${task.title}".`;
  const filesChanged = result.filesChanged.length || diffStats.filesChanged;
  const filesPreview = renderFilesPreview(result.filesChanged);

  return [
    "## Summary",
    "",
    summaryText,
    "",
    "## Changes",
    "",
    filesPreview,
    "",
    `- **Files changed:** ${filesChanged}`,
    `- **Lines added:** ${diffStats.linesAdded}`,
    `- **Lines removed:** ${diffStats.linesRemoved}`,
    "",
    "## Context",
    "",
    `- **Task source:** ${task.source}`,
    `- **Agent:** ${agentLabel}`,
    `- **Tokens used:** ${result.totalTokensUsed}`,
    `- **Execution time:** ${durationText}`,
    linkedIssue.trimEnd(),
    "",
    "---",
    "*This PR was automatically generated by OAC.*",
  ].join("\n");
}

async function resolveDiffStats(
  repo: ResolvedRepo,
  baseBranch: string,
  branchName: string,
): Promise<PRDiffStats> {
  const git = simpleGit(resolveGitPath(repo));
  const ranges = [
    [`origin/${baseBranch}...${branchName}`],
    [`${baseBranch}...${branchName}`],
    ["HEAD"],
    [],
  ] as string[][];

  for (const range of ranges) {
    try {
      const summary = await git.diffSummary(range);
      return {
        filesChanged: summary.changed,
        linesAdded: summary.insertions,
        linesRemoved: summary.deletions,
      };
    } catch {}
  }

  return {
    filesChanged: 0,
    linesAdded: 0,
    linesRemoved: 0,
  };
}

async function addLabels(
  octokit: Octokit,
  repo: ResolvedRepo,
  prNumber: number,
  labels: string[],
): Promise<void> {
  const uniqueLabels = [...new Set(labels.map((label) => label.trim()).filter(Boolean))];
  if (uniqueLabels.length === 0) {
    return;
  }

  try {
    await octokit.issues.addLabels({
      owner: repo.owner,
      repo: repo.name,
      issue_number: prNumber,
      labels: uniqueLabels,
    });
  } catch {
    // Labeling failure should not block PR creation.
  }
}

function resolveGitPath(repo: ResolvedRepo): string {
  return repo.worktreePath.trim().length > 0 ? repo.worktreePath : repo.localPath;
}

async function readRemoteBranchSha(
  git: SimpleGit,
  branchName: string,
): Promise<string | undefined> {
  const remoteHeads = await git.listRemote(["--heads", "origin", branchName]);
  const firstLine = remoteHeads
    .split("\n")
    .map((line) => line.trim())
    .find((line) => line.length > 0);

  if (!firstLine) {
    return undefined;
  }

  const [sha] = firstLine.split(/\s+/);
  return sha;
}

function resolveAgentLabel(metadata: Record<string, unknown>): string {
  const fromAgent = readMetadataString(metadata, ["agent", "agentName", "provider"]);
  return fromAgent ?? "unknown";
}

function readMetadataString(metadata: Record<string, unknown>, keys: string[]): string | undefined {
  for (const key of keys) {
    const value = metadata[key];
    if (typeof value === "string" && value.trim().length > 0) {
      return value.trim();
    }
  }
  return undefined;
}

function renderFilesPreview(files: string[]): string {
  if (files.length === 0) {
    return "- No file list was reported by the execution step.";
  }

  const preview = files.slice(0, 15).map((path) => `- \`${path}\``);
  if (files.length > 15) {
    preview.push(`- ...and ${files.length - 15} more file(s)`);
  }

  return preview.join("\n");
}

function formatDurationSeconds(duration: number): string {
  if (!Number.isFinite(duration) || duration <= 0) {
    return "0s";
  }

  const seconds = duration > 1_000 ? duration / 1_000 : duration;
  if (seconds >= 100) {
    return `${Math.round(seconds)}s`;
  }

  return `${seconds.toFixed(1)}s`;
}
